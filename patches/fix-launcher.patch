diff --git a/PC/launcher2.c b/PC/launcher2.c
--- a/PC/launcher2.c
+++ b/PC/launcher2.c
@@ -13,6 +13,7 @@
 #include <fcntl.h>
 #include <io.h>
 #include <shlobj.h>
+#include <shlwapi.h>
 #include <stdio.h>
 #include <stdbool.h>
 #include <tchar.h>
@@ -202,11 +203,43 @@ _compare(const wchar_t *x, int xLen, const wchar_t *y, int yLen)
     } else if (!y || !yLen) {
         return 1;
     }
-    switch (CompareStringEx(
+    int rc = CompareStringEx(
         LOCALE_NAME_INVARIANT, NORM_IGNORECASE | SORT_DIGITSASNUMBERS,
         x, xLen, y, yLen,
         NULL, NULL, 0
-    )) {
+    );
+    DWORD err = GetLastError();
+    if (!rc && err == ERROR_INVALID_FLAGS) {
+        // Windows Vista does not support SORT_DIGITSASNUMBERS
+        const wchar_t* xNew = x;
+        const wchar_t* yNew = y;
+        wchar_t* xBuf = NULL;
+        if (xLen > 0) {
+            xBuf = malloc((xLen + 1) * sizeof(wchar_t));
+            if (xBuf) {
+                wcsncpy_s(xBuf, xLen + 1, x, xLen);
+                xBuf[xLen] = L'\0';
+            }
+            xNew = xBuf;
+        }
+        wchar_t* yBuf = NULL;
+        if (yLen > 0) {
+            wchar_t* yBuf = malloc((yLen + 1) * sizeof(wchar_t));
+            if (yBuf) {
+                wcsncpy_s(yBuf, yLen + 1, y, yLen);
+                yBuf[yLen] = L'\0';
+            }
+            yNew = yBuf;
+        }
+        if (xNew && yNew) {
+            rc = StrCmpLogicalW(xNew, yNew) + 2;
+        } else {
+            err = ERROR_OUTOFMEMORY;
+        }
+        free(xBuf);
+        free(yBuf);
+    }
+    switch (rc) {
     case CSTR_LESS_THAN:
         return -1;
     case CSTR_EQUAL:
@@ -214,7 +247,7 @@ _compare(const wchar_t *x, int xLen, const wchar_t *y, int yLen)
     case CSTR_GREATER_THAN:
         return 1;
     default:
-        winerror(0, L"Error comparing '%.*s' and '%.*s' (compare)", xLen, x, yLen, y);
+        winerror(err, L"Error comparing '%.*s' and '%.*s' (compare)", xLen, x, yLen, y);
         return -1;
     }
 }
@@ -823,7 +856,11 @@ _readIni(const wchar_t *section, const wchar_t *settingName, wchar_t *buffer, in
     if (SUCCEEDED(SHGetFolderPathW(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, iniPath)) &&
         join(iniPath, MAXLEN, L"py.ini")) {
         debug(L"# Reading from %s for %s/%s\n", iniPath, section, settingName);
-        n = GetPrivateProfileStringW(section, settingName, NULL, buffer, bufferLength, iniPath);
+        if ((n = PathFileExistsW(iniPath))) {
+            // On Windows Vista, GetPrivateProfileStringW() does not properly
+            // set the ERROR_FILE_NOT_FOUND error code
+            n = GetPrivateProfileStringW(section, settingName, NULL, buffer, bufferLength, iniPath);
+        }
         if (n) {
             debug(L"# Found %s in %s\n", settingName, iniPath);
             return n;
@@ -837,7 +874,11 @@ _readIni(const wchar_t *section, const wchar_t *settingName, wchar_t *buffer, in
         SUCCEEDED(PathCchRemoveFileSpec(iniPath, MAXLEN)) &&
         join(iniPath, MAXLEN, L"py.ini")) {
         debug(L"# Reading from %s for %s/%s\n", iniPath, section, settingName);
-        n = GetPrivateProfileStringW(section, settingName, NULL, buffer, MAXLEN, iniPath);
+        if ((n = PathFileExistsW(iniPath))) {
+            // On Windows Vista, GetPrivateProfileStringW() does not properly
+            // set the ERROR_FILE_NOT_FOUND error code
+            n = GetPrivateProfileStringW(section, settingName, NULL, buffer, MAXLEN, iniPath);
+        }
         if (n) {
             debug(L"# Found %s in %s\n", settingName, iniPath);
             return n;
@@ -1288,6 +1329,156 @@ addEnvironmentInfo(EnvironmentInfo **root, EnvironmentInfo *node)
 \******************************************************************************/
 
 
+static void apply_restrictions(DWORD dwFlags, DWORD dwType, DWORD cbData, PLONG ret)
+{
+    /* Check if the type is restricted by the passed flags */
+    if (*ret == ERROR_SUCCESS || *ret == ERROR_MORE_DATA)
+    {
+        DWORD dwMask = 0;
+
+        switch (dwType)
+        {
+        case REG_NONE: dwMask = RRF_RT_REG_NONE; break;
+        case REG_SZ: dwMask = RRF_RT_REG_SZ; break;
+        case REG_EXPAND_SZ: dwMask = RRF_RT_REG_EXPAND_SZ; break;
+        case REG_MULTI_SZ: dwMask = RRF_RT_REG_MULTI_SZ; break;
+        case REG_BINARY: dwMask = RRF_RT_REG_BINARY; break;
+        case REG_DWORD: dwMask = RRF_RT_REG_DWORD; break;
+        case REG_QWORD: dwMask = RRF_RT_REG_QWORD; break;
+        }
+
+        if (dwFlags & dwMask)
+        {
+            /* Type is not restricted, check for size mismatch */
+            if (dwType == REG_BINARY)
+            {
+                DWORD cbExpect = 0;
+
+                if ((dwFlags & RRF_RT_ANY) == RRF_RT_DWORD)
+                    cbExpect = 4;
+                else if ((dwFlags & RRF_RT_ANY) == RRF_RT_QWORD)
+                    cbExpect = 8;
+
+                if (cbExpect && cbData != cbExpect)
+                    *ret = ERROR_DATATYPE_MISMATCH;
+            }
+        } else *ret = ERROR_UNSUPPORTED_TYPE;
+    }
+}
+
+static inline BOOL is_string(DWORD type)
+{
+    return (type == REG_SZ) || (type == REG_EXPAND_SZ) || (type == REG_MULTI_SZ);
+}
+
+static LSTATUS Py_RegGetValueW(HKEY hKey, LPCWSTR pszSubKey, LPCWSTR pszValue,
+    DWORD dwFlags, LPDWORD pdwType, PVOID pvData,
+    LPDWORD pcbData)
+{
+    // Windows 7 and under have a bug where RegGetValueW() returns ERROR_INVALID_PARAMETER
+    LONG ret = RegGetValueW(hKey, pszSubKey, pszValue, dwFlags, pdwType, pvData, pcbData);
+    if (ret != ERROR_INVALID_PARAMETER)
+        return ret;
+
+    DWORD dwType, cbData = (pvData && pcbData) ? *pcbData : 0;
+    PVOID pvBuf = NULL;
+
+    if (pvData && !pcbData)
+        return ERROR_INVALID_PARAMETER;
+
+    if ((dwFlags & RRF_RT_REG_EXPAND_SZ) && !(dwFlags & (RRF_NOEXPAND | RRF_RT_REG_SZ)) &&
+        ((dwFlags & RRF_RT_ANY) != RRF_RT_ANY))
+        return ERROR_INVALID_PARAMETER;
+
+    if ((dwFlags & RRF_WOW64_MASK) == RRF_WOW64_MASK)
+        return ERROR_INVALID_PARAMETER;
+
+    if (pszSubKey && pszSubKey[0])
+    {
+        REGSAM samDesired = KEY_QUERY_VALUE;
+
+        if (dwFlags & RRF_WOW64_MASK)
+            samDesired |= (dwFlags & RRF_SUBKEY_WOW6432KEY) ? KEY_WOW64_32KEY : KEY_WOW64_64KEY;
+
+        ret = RegOpenKeyExW(hKey, pszSubKey, 0, samDesired, &hKey);
+        if (ret != ERROR_SUCCESS) return ret;
+    }
+
+    ret = RegQueryValueExW(hKey, pszValue, NULL, &dwType, pvData, &cbData);
+
+    /* If the value is a string, we need to read in the whole value to be able
+     * to know exactly how many bytes are needed after expanding the string and
+     * ensuring that it is null-terminated. */
+    if (is_string(dwType) &&
+        (ret == ERROR_MORE_DATA ||
+            (ret == ERROR_SUCCESS && dwType == REG_EXPAND_SZ && !(dwFlags & RRF_NOEXPAND)) ||
+            (ret == ERROR_SUCCESS && (cbData < sizeof(WCHAR) || (pvData && *((WCHAR *)pvData + cbData / sizeof(WCHAR) - 1))))))
+    {
+        do {
+            HeapFree(GetProcessHeap(), 0, pvBuf);
+
+            pvBuf = HeapAlloc(GetProcessHeap(), 0, cbData + sizeof(WCHAR));
+            if (!pvBuf)
+            {
+                ret = ERROR_NOT_ENOUGH_MEMORY;
+                break;
+            }
+
+            if (ret == ERROR_MORE_DATA || !pvData)
+                ret = RegQueryValueExW(hKey, pszValue, NULL,
+                    &dwType, pvBuf, &cbData);
+            else
+            {
+                /* Even if cbData was large enough we have to copy the
+                 * string since ExpandEnvironmentStrings can't handle
+                 * overlapping buffers. */
+                CopyMemory(pvBuf, pvData, cbData);
+            }
+        } while (ret == ERROR_MORE_DATA);
+
+        if (ret == ERROR_SUCCESS)
+        {
+            /* Ensure null termination */
+            if (cbData < sizeof(WCHAR) || *((WCHAR *)pvBuf + cbData / sizeof(WCHAR) - 1))
+            {
+                *((WCHAR *)pvBuf + cbData / sizeof(WCHAR)) = 0;
+                cbData += sizeof(WCHAR);
+            }
+
+            /* Recheck dwType in case it changed since the first call */
+            if (dwType == REG_EXPAND_SZ && !(dwFlags & RRF_NOEXPAND))
+            {
+                cbData = ExpandEnvironmentStringsW(pvBuf, pvData,
+                    pcbData ? *pcbData : 0) * sizeof(WCHAR);
+                dwType = REG_SZ;
+                if (pvData && cbData > *pcbData)
+                    ret = ERROR_MORE_DATA;
+            } else if (pvData)
+            {
+                if (cbData > *pcbData)
+                    ret = ERROR_MORE_DATA;
+                else
+                    CopyMemory(pvData, pvBuf, cbData);
+            }
+        }
+
+        HeapFree(GetProcessHeap(), 0, pvBuf);
+    }
+
+    if (pszSubKey && pszSubKey[0])
+        RegCloseKey(hKey);
+
+    apply_restrictions(dwFlags, dwType, cbData, &ret);
+
+    if (pvData && ret != ERROR_SUCCESS && (dwFlags & RRF_ZEROONFAILURE))
+        ZeroMemory(pvData, *pcbData);
+
+    if (pdwType) *pdwType = dwType;
+    if (pcbData) *pcbData = cbData;
+
+    return ret;
+}
+
 int
 _registryReadString(const wchar_t **dest, HKEY root, const wchar_t *subkey, const wchar_t *value)
 {
@@ -1295,7 +1486,7 @@ _registryReadString(const wchar_t **dest, HKEY root, const wchar_t *subkey, cons
     DWORD cbData = 0;
     DWORD flags = RRF_RT_REG_SZ | RRF_RT_REG_EXPAND_SZ;
 
-    if (ERROR_SUCCESS != RegGetValueW(root, subkey, value, flags, NULL, NULL, &cbData)) {
+    if (ERROR_SUCCESS != Py_RegGetValueW(root, subkey, value, flags, NULL, NULL, &cbData)) {
         return 0;
     }
 
@@ -1304,7 +1495,7 @@ _registryReadString(const wchar_t **dest, HKEY root, const wchar_t *subkey, cons
         return RC_NO_MEMORY;
     }
 
-    if (ERROR_SUCCESS == RegGetValueW(root, subkey, value, flags, NULL, buffer, &cbData)) {
+    if (ERROR_SUCCESS == Py_RegGetValueW(root, subkey, value, flags, NULL, buffer, &cbData)) {
         *dest = buffer;
     } else {
         free((void *)buffer);
diff --git a/PCbuild/pylauncher.vcxproj b/PCbuild/pylauncher.vcxproj
--- a/PCbuild/pylauncher.vcxproj
+++ b/PCbuild/pylauncher.vcxproj
@@ -95,7 +95,7 @@
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>shell32.lib;pathcch.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>shell32.lib;pathcch.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <SubSystem>Console</SubSystem>
     </Link>
   </ItemDefinitionGroup>
diff --git a/PCbuild/pywlauncher.vcxproj b/PCbuild/pywlauncher.vcxproj
--- a/PCbuild/pywlauncher.vcxproj
+++ b/PCbuild/pywlauncher.vcxproj
@@ -95,7 +95,7 @@
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>shell32.lib;pathcch.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>shell32.lib;pathcch.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <SubSystem>Windows</SubSystem>
     </Link>
   </ItemDefinitionGroup>
diff --git a/Tools/msi/bundle/packagegroups/postinstall.wxs b/Tools/msi/bundle/packagegroups/postinstall.wxs
--- a/Tools/msi/bundle/packagegroups/postinstall.wxs
+++ b/Tools/msi/bundle/packagegroups/postinstall.wxs
@@ -52,7 +52,9 @@
                         Permanent="yes"
                         PerMachine="yes"
                         Vital="no"
-                        InstallCondition="InstallAllUsers and CompileAll and not LauncherOnly" />
+                        InstallCondition="InstallAllUsers and CompileAll and not LauncherOnly">
+                <Payload Id="payload_compileall_AllUsers" SourceFile="api-ms-win-core-path-l1-1-0.dll" Compressed="yes" />
+            </ExePackage>
             <ExePackage Id="compileallO_AllUsers"
                         SourceFile="py.exe"
                         Compressed="yes"
@@ -62,7 +64,9 @@
                         Permanent="yes"
                         PerMachine="yes"
                         Vital="no"
-                        InstallCondition="InstallAllUsers and CompileAll and not LauncherOnly" />
+                        InstallCondition="InstallAllUsers and CompileAll and not LauncherOnly">
+                <Payload Id="payload_compileallO_AllUsers" SourceFile="api-ms-win-core-path-l1-1-0.dll" Compressed="yes" />
+            </ExePackage>
             <ExePackage Id="compileallOO_AllUsers"
                         SourceFile="py.exe"
                         Compressed="yes"
@@ -72,7 +76,9 @@
                         Permanent="yes"
                         PerMachine="yes"
                         Vital="no"
-                        InstallCondition="InstallAllUsers and CompileAll and not LauncherOnly" />
+                        InstallCondition="InstallAllUsers and CompileAll and not LauncherOnly">
+                <Payload Id="payload_compileallOO_AllUsers" SourceFile="api-ms-win-core-path-l1-1-0.dll" Compressed="yes" />
+            </ExePackage>
 
             <ExePackage Id="compileall_JustForMe"
                         SourceFile="py.exe"
@@ -83,7 +89,9 @@
                         Permanent="yes"
                         PerMachine="no"
                         Vital="no"
-                        InstallCondition="not InstallAllUsers and CompileAll and not LauncherOnly" />
+                        InstallCondition="not InstallAllUsers and CompileAll and not LauncherOnly">
+                <Payload Id="payload_compileall_JustForMe" SourceFile="api-ms-win-core-path-l1-1-0.dll" Compressed="yes" />
+            </ExePackage>
             <ExePackage Id="compileallO_JustForMe"
                         SourceFile="py.exe"
                         Compressed="yes"
@@ -93,7 +101,9 @@
                         Permanent="yes"
                         PerMachine="no"
                         Vital="no"
-                        InstallCondition="not InstallAllUsers and CompileAll and not LauncherOnly" />
+                        InstallCondition="not InstallAllUsers and CompileAll and not LauncherOnly">
+                <Payload Id="payload_compileallO_JustForMe" SourceFile="api-ms-win-core-path-l1-1-0.dll" Compressed="yes" />
+            </ExePackage>
             <ExePackage Id="compileallOO_JustForMe"
                         SourceFile="py.exe"
                         Compressed="yes"
@@ -103,7 +113,9 @@
                         Permanent="yes"
                         PerMachine="no"
                         Vital="no"
-                        InstallCondition="not InstallAllUsers and CompileAll and not LauncherOnly" />
+                        InstallCondition="not InstallAllUsers and CompileAll and not LauncherOnly">
+                <Payload Id="payload_compileallOO_JustForMe" SourceFile="api-ms-win-core-path-l1-1-0.dll" Compressed="yes" />
+            </ExePackage>
         </PackageGroup>
     </Fragment>
 </Wix>
diff --git a/Tools/msi/launcher/launcher_files.wxs b/Tools/msi/launcher/launcher_files.wxs
--- a/Tools/msi/launcher/launcher_files.wxs
+++ b/Tools/msi/launcher/launcher_files.wxs
@@ -9,6 +9,9 @@
             <Component Id="pyw.exe" Directory="LauncherInstallDirectory" Guid="{8E52B8CD-48BB-4D74-84CD-6238BCD11F20}">
                 <File Id="pyw.exe" Name="pyw.exe" Source="pyw.exe" KeyPath="yes" />
             </Component>
+            <Component Id="api_ms_win_core_path_l1_1_0.dll" Directory="LauncherInstallDirectory" Guid="{7BADFF1C-D76A-4F9B-A955-09E6EC1614B7}">
+                <File Id="api_ms_win_core_path_l1_1_0.dll" Name="api-ms-win-core-path-l1-1-0.dll" Source="api-ms-win-core-path-l1-1-0.dll" KeyPath="yes" />
+            </Component>
 
             <Component Id="launcher_path_cu" Directory="LauncherInstallDirectory" Guid="{95AEB930-367C-475C-A17E-A89BFCD4C670}">
                 <Condition>NOT ALLUSERS=1</Condition>
